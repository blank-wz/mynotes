## 1.1 二分查找

计算机科学中，**时间复杂度**是用来衡量： 一个算法的执行，随数据规模增大，而增长的时间成本

+ 不依赖于环境因素

如何表示时间复杂度

+ 假设算法要处理的数据规模是n， 代码总的执行行数用函数 f(n) 来表示，例如：
  * 线性查找算法的函数 f(n) = 3 * n + 3
  * 二分查找算法的函数 f(n) = (floor(log2(n)) + 1) * 5 + 4
+ 为了对 f(n) 进行简化，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法

### 大 O 表示法

![image-20240106165135993](C:\Users\blank\AppData\Roaming\Typora\typora-user-images\image-20240106165135993.png)

asymptotic upper bound

渐进上界：从某个常熟 n0 开始，c*g(n) 总是位于 f(n) 上方， 那么记作 O(g(n))

asymptotic lower bound

渐进下界：从某个常数 n0 开始，c*g(n) 总是位于 f(n) 下方， 那么记作 Ω(g(n))

asymptotic tight bounds

渐进紧界：从某个常数 n0 开始，f(n) 总是在 c1*g(n) 和 c2 *g(n) 之间， 那么记作 (g(n))

![image-20240106170401145](C:\Users\blank\AppData\Roaming\Typora\typora-user-images\image-20240106170401145.png)

按时间复杂度从低到高

+ 黑色横线 O(1)，常量时间，意味着算法时间并不随数据规模而变化
+ 绿色 O(log(n))，对数时间
+ 蓝色 O(n)，线性时间，算法时间与数据规模成正比
+ 橙色 O(n*log(n))，拟线性时间
+ 红色 O(n2) 平方时间
+ 黑色朝上 O(2^n) 指数时间
+ 没画出来的 O(n!)



## 2.2 数组

### 定义

在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识

因为数组内的元素是**连续存储**的，所以数组中元素的地址，可以通过其索引计算出来，例如

````java
int[] array = {1, 2, 3, 4, 5}
````



知道了数组的**数据**起始地址 *BaseAddress*，就可以由公式 *BaseAddress + i \* size* 计算出索引 i 元素的地址

+ i 即索引，在 Java C 等语言都是从 0 开始
+ size 是每个元素占用字节，例如 int 占 4，double 占 8