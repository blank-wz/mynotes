# 一, 概述 (Remote Dictionary Server)

​		Redis是一个key-value存储系统，是一个分布式缓存数据库。和Memcached类似，但是，它支持存储的value类型相对更多，包括string（字符串），hash（哈希），list（列表），set（集合）及 zset(sorted set：有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

​		redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。



# 二, Redis 基本特性

1. 多种数据类型存储（string（字符串），hash（哈希），list（列表），set（集合）及 zset(sorted set：有序集合)）。
2. 内存存储与持久化（RDB,AOF）。
3. 功能丰富（数据库、缓存、队列等）。
4. 简单稳定（基于c语言实现）。
5. 所有操作都是原子性的。



# 三, Redis 的三大问题

## 1. 缓存穿透

即黑客故意去请求缓存中不存在的数据，导致所有的请求都到数据库去查，从而数据库连接异常

解决方案:

1. 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
2. 采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
3. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。



## 2. 缓存雪崩

即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常

解决方案：

1. 给缓存的失效时间，加上一个随机值，避免集体失效。
2. 使用互斥锁，但是该方案吞吐量明显下降了。
3. 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作

双缓存的实现过程：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。


## 3. 缓存击穿

热点数据过期时间刚好过期了。所有的请求都打在数据库上了，造成数据库的瘫痪

解决方案：

1. 使用互斥锁进行重建缓存
2. 设置热点数据永远不过期



# 三, Redis 数据持久化

## 1. RDB 方式持久化

### 1.1 原理

是将Reids在内存中的数据库记录定时 dump 到磁盘上的 RDB 持久化

### 1.2 优点

1. RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据
2. RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。
3. 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速.

### 1.3 缺点

如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据



## 2. AOF 持久化

### 2.1 原理

append only file原理是将 Reids 的操作日志以追加的方式写入文件

### 2.2 优点

1. AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据.
2. AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复
3. AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。
4. AOF日志文件的命令通过易读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据.

### 2.3 缺点

1. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大
2. AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的
3. 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。

## 3. RDB 和 AOF 的区别

一个是持续的用日志记录写操作，crash（崩溃）后利用日志恢复；一个是平时写操作的时候不触发写，会在一定时间间隔或手动提交save命令，shutdown关闭命令时，才触发备份操作



# 四, Redis 事务管理

redis是单线程(但是在6.0中真正引用多线程的应用)，提交命令时，其它命令无法插入其中，轻松利用单线程实现了事务的原子性。那如果执行多个redis命令呢？自然就没有事务保证，于是redis有下列相关的redis命令来实现事务管理

```
multi		开启事务
exec		提交事务
discard		取消事务
watch		监控，如果监控的值发生变化，则提交事务时会失败
unwatch		解除监控
```

Redis保证一个事务中的所有命令要么都执行，要么都不执行(原子性)。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。



# 五, Redis 主从复制



1. 将redis01拷贝两份，例如

   ```Linux
   cp -r redis01/  redis02
   cp -r redis01/  redis03
   ```

2. 假如已有redis服务，先将原先所有redis服务停止删除，并启动新的redis容器，例如

   ```
   docker run -p 6379:6379 --name redis6379 \
   -v /usr/local/docker/redis01/data:/data \
   -v /usr/local/docker/redis01/conf/redis.conf:/etc/redis/redis.conf \
   -d redis redis-server /etc/redis/redis.conf \
   --appendonly yes
   
   6379/6380/6381
   ```

3. 检测redis服务角色

   分别登陆三台redis容器服务，通过info指令进行角色查看，默认新启动的三个redis服务角色都为master

4. 检测redis6379的ip设置(将这个服务设置为master)

5. 设置Master/Slave架构

6. 再次登陆redis6379，然后检测info

7. 登陆redis6379测试，master都写都可以

8. 登陆redis6380测试，slave只能读

   

# 六, Redis 集群高可用

对于redis集群(Cluster),一般最少设置为6个节点,3个master,3个slave,其简易架构如下





## 小结面试分析

String

§  博客的字数统计如何实现？（strlen）

§  如何将审计日志不断追加到指定key?(append)

§  你如何实现一个分布式自增id？(incr-雪花算法)

§  如何实现一个博客的的点赞操作？(incr,decr)

Key有效时间

§  为什么要设置key的有效时长？(释放空间，业务需要)

§  秒杀操作的计时是如何实现？(pexpire 以毫秒为单位)

§  如何设置缓存数据的有效时长?(expire-秒，pexpire -毫秒)

§  假如将登录状态存储了redis,如何设置登录的有效时长?

Hash

§  发布一篇博客需要写内存吗？（需要,hmset）

§  浏览博客内容会怎么做？（hmget）

§  如何判定一篇博客是否存在？(hexists)

§  删除一篇博客如何实现？(hdel)

§  分布式系统中你登录成功以后是如何存储用户信息的？(hmset)

List

§  如何基于redis实现一个队列结构？（lpush/rpop）

§  如何基于redis实现一个栈结构？(lpush/lpop)

§  如何基于redis实现一个阻塞式队列？(lpush/brpop)

§  如何实现秒杀活动的公平性？(先进先出-FIFO)

§  通过list结构实现一个消息队列(顺序)吗？（可以，FIFO->lpush,rpop）

§  用户注册时的邮件发送功能如何提高其效率？(邮件发送是要调用三方服务，底层通过队列优化其效率，队列一般是list结构)

§  如何动态更新商品的销量列表？(卖的好的排名靠前一些，linsert)

§  商家的粉丝列表使用什么结构实现呢？(list结构)

Set

§  朋友圈的点赞功能你如何实现？（sadd,srem,smembers,scard）

§  如何实现一个网站投票统计程序?

§  你知道微博中的关注如何实现吗？
