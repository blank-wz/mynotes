# 数据库 - MySQL



MySQL 常用数据类型



字符串的基本使用

char(size) 固定长度字符串, 最大255字符

varchar(size)   可变长度字符串 最大65535字节 (utf8 编码最大21844字符,1-3个字节用于记录大小) 

char(4) 和 varchar(4)  4表示的是字符,而不是字节, 不区分字符是汉字还是字母

如果varchar 不够用,可以考虑使用 text, mediumtext 或者 longtext





## 事务的4个特性 ACID

原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）

1. **原子性**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中如果发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
2. **一致性**：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
3. **隔离性**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
4. **持久性**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



## 事务的隔离级别

1. 读未提交（Read uncommitted） 安全性最差,可能发生并发数据问题,性能最好
2. 读提交（read committed）   Oracle默认的隔离级别
3. 可重复读（repeatable read）MySQL默认的隔离级别,安全性较好,性能一般
4. 串行化（Serializable）    表级锁，读写都加锁，效率低下,安全性高,不能并发



## 数据库优化

### 1) 数据库服务器内核优化

### 2) my.cnf 配置, 一般搭配压力测试进行调试

### 3) SQL 语句优化

1. 查询SQL尽量不要使用select *，而是具体字段
2. where限定查询的数据 (需要什么数据，就去查什么数据，避免返回不必要的数据)
3. 避免在where子句中使用or来连接条件 (使用or可能会使索引失效，从而全表扫描)
4. 提高group by语句的效率 (先过滤，后分组)
5. 使用varchar代替char
6. 尽量使用数值替代字符串类型
7. 使用 explain 分析你 SQL 执行计划
8. 优化 like 语句
9. 索引不宜太多，一般5个以内
10. 索引不适合建在有大量重复数据的字段上 (Mysql 查询优化器推算发现不走索引的成本更低，很可能就放弃索引了)
11. 避免对索引字段进行计算、避免索引在字段上使用**not、<>、！=、**避免在索引上使用**IS NULL和NOT NULL**、**避免在索引列上出现数据类型转换、避免索引字段使用函数、避免建立索引的列出现空值**
12. 去重 distinct 过滤字段要少
13. where 中使用默认值代替 null
14. 批量插入性能提升 (默认新增SQL有事务控制，导致每条都需要事务开启和事务提交；而批量处理是一次事务开启和提交。自然速度飞升)
15. 批量删除优化 (避免同时修改或删除过多数据，因为会造成cpu利用率过高，一次性删除太多数据，可能造成锁表，会有 lock wait timeout exceed 的错误，所以建议分批操作)
16. 伪删除设计
17. 不要有超过5个以上的表连接
18. inner join 、left join、right join，优先使用inner join



# 建表(表设计)需要注意什么

+ 库名、表名、字段名必须使用小写字母，“_”分割。
+ 库名、表名、字段名必须不超过12个字符。
+ 库名、表名、字段名见名知意,建议使用名词而不是动词。
+ 建议使用InnoDB存储引擎。
+ 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE。
+ 建议使用UNSIGNED存储非负数值。
+ 建议使用INT UNSIGNED存储IPV4。
+ 整形定义中不添加长度，比如使用INT，而不是INT(4)。
+ 使用短数据类型，比如取值范围为0-80时，使用TINYINT UNSIGNED。
+ 不建议使用ENUM类型，使用TINYINT来代替。
+ 尽可能不使用TEXT、BLOB类型。
+ VARCHAR(N)，N表示的是字符数不是字节数，比如VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N。
+ VARCHAR(N)，N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。
+ 表字符集选择UTF8。
+ 使用VARBINARY存储变长字符串。
+ 存储年使用YEAR类型。
+ 存储日期使用DATE类型。
+ 存储时间（精确到秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。
+ 建议字段定义为NOT NULL。
+ 将过大字段拆分到其他表中。
+ 禁止在数据库中使用VARBINARY、BLOB存储图片、文件等。



# 表设计

1. 命名规范

2. 选择合适的字段类型

3. 主键设计要合理

4. 选择合适的字段长度

5. 优先考虑逻辑删除，而不是物理删除

6. 每个表都需要添加几个通用字段

7. 一张表的字段不宜过多

8. 尽可能使用 not null 定义字段

9. 设计表时，评估哪些字段需要加索引

10. 不需要严格遵守 3NF，通过业务字段冗余来减少表关联

11. 避免使用 MySQL 保留字

12. 不搞外键关联，一般都在代码维护

13. 一般都选择 INNODB 存储引擎

14. 选择合适统一的字符集

15. 如果数据库字段是枚举类型的，需要在 comment 注释清楚

16. 时间的类型选择

17. 不建议使用存储过程、触发器

18. 1:N 关系的设计

19. 大字段的存储

20. 考虑是否需要分库分表



# SQL 优化

- 查询 SQL 尽量不要使用`select *`，而是`select`具体字段。
- 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用`limit 1`。
- 应尽量避免在`where`子句中使用`or`来连接条件。
- 注意优化`limit`深分页问题。
- 使用`where`条件限定要查询的数据，避免返回多余的行。
- 尽量避免在索引列上使用`mysql`的内置函数。
- 应尽量避免在 `where`子句中对字段进行表达式操作。
- 应尽量避免在`where`子句中使用`!=`或`<>`操作符。
- 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
- 对查询进行优化，应考虑在`where 及 order by`涉及的列上建立索引。
- 如果插入数据过多，考虑批量插入。
- 在适当的时候，使用覆盖索引。
- 使用 explain 分析 SQL 的计划。



**一、数据索引是干什么用的呢？**

数据库索引其实就是为了使查询数据效率快。

**二、数据库索引有哪些呢？**

1. 聚集索引（主键索引）：在数据库里面，所有行数都会按照主键索引进行排序。
2. 非聚集索引：就是给普通字段加上索引。
3. 组合索引：就是好几个字段组成的索引，称为组合索引。

```
key ``'idx_age_name_sex'` `(``'age'``,``'name'``,``'sex'``)
```

　　联合索引遵从最左前缀原则。

**三、索引在那些情况下失效呢？**

表student中两个字段age,name加了索引

```
key ``'idx_age'``(``'age'``),
key ``'idx_name'` `(``'name'``)
```

 

1. Like这种就是%在前面的不走索引，在后面的走索引（A走索引，B不走索引）

```
A:select * from student where 'name' like '王%'
B:select * from student where 'name' like '%小'
```

2. 用索引列进行计算的，不走索引（A走索引，B不走索引）

```
A:select * from student where age = 10+8
B:select * from student where age + 8 = 18
```

3. 对索引列用函数了，不走索引（A不走索引，B走索引）

```
A:select * from student where  concat('name','哈') ='王哈哈';
B:select * from student where name = concat('王哈','哈');
```

4. 索引列用了!= , <>不走索引

```
select * from student where age != 18
```

5. 索引字段进行判空查询时。也就是对索引字段判断是否为NULL时

```
select * from student where name is null
```

6. 随着表的增长，where条件出来的数据太多，大于15%，使得索引失效

7. 避免在where子句中使用`or`来连接条件,因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描

```
SELECT id FROM table WHERE num = 0 OR num = 1
```
